# Compiler Project

## Overview

This project implements a simple compiler that translates a high-level language into assembly code. The compiler consists of three main components:
1. **Lexer**: Tokenizes the input source code.
2. **Parser**: Parses the tokens and generates an Abstract Syntax Tree (AST).
3. **Code Generator**: Converts the AST into assembly code.

## Prerequisites

- GCC compiler
- Basic understanding of compiler design
- 8-bit Computer Simulator[https://github.com/lightcode/8bit-computer]

## Steps to follow

### Step 1: Setup the 8-bit CPU Simulator

1. **Clone the Repository**: The 8-bit CPU repository was cloned from [GitHub](https://github.com/lightcode/8bit-computer):
   ```bash
   git clone https://github.com/lightcode/8bit-computer
   cd 8bit-computer
   ```
3. **Run Programs**:
   - Assemble the `multiplication_test.asm` example:
     ```bash
     ./asm/asm.py tests/multiplication_test.asm > memory.list
     ```
   - Execute the CPU simulator:
     ```bash
     make clean && make run
     ```

### Step 2: Understand the 8-bit CPU Architecture

1. **Review Verilog Code**:
   - Key files in the `rtl/` directory, such as `machine.v`, were studied to understand instruction processing and component interactions.
2. **Instruction Set**:
   - Data Transfer: `lda`, `sta`, `mov`
   - Arithmetic: `add`, `sub`, `inc`, `dec`
   - Logical: `and`, `or`, `xor`
   - Branching: `jmp`, `jz`, `jc`
   - Control: `hlt`, `nop`
3. **State Machine**:
   - Example States: `FETCH_INST`, `EXECUTE`, `HALT`
4. **Analyze Examples**:
   - The `multiplication_test` program was reviewed to understand instruction flow and CPU operation.

### Step 3: Design SimpleLang

1. **Language Constructs**:
   - **Variable Declaration**: `int <var_name>;` (e.g., `int a;`)
   - **Assignment**: `<var_name> = <expression>;` (e.g., `a = b + c;`)
   - **Arithmetic Operations**: Supported operators are `+` and `-` (e.g., `a = b - c;`)
   - **Conditionals**: `if (<condition>) { <statements> }` (e.g., `if (a == b) { a = a + 1; }`)

**Example Program**:
   ```c
   // Variable declaration
   int a;
   int b;
   int c;

   // Assignment
   a = 10;
   b = 20;
   c = a + b;

   // Conditional
   if (c == 30) {
       c = c + 1;
   }
   ```
**3. Parsing Design**
The constructs above are implemented based on this high-level grammar:
- **Variable Declarations**:
  ```
  Declaration -> "int" Identifier ";"
  ```
- **Assignments**:
  ```
  Assignment -> Identifier "=" Expression ";"
  Expression -> Identifier | Number | Expression "+" Expression | Expression "-" Expression
  ```
- **Conditionals**:
  ```
  Conditional -> "if" "(" Condition ")" Block
  Condition -> Expression "==" Expression
  Block -> "{" StatementList "}"
  StatementList -> Statement | StatementList Statement
  ```
**4. Mapping to Assembly**
Translate each construct to the CPUâ€™s instruction set:
     - `int a;` maps to memory allocation.
     - `a = 10;` maps to `ldi` (load immediate) and `sta` (store accumulator).
     - `c = a + b;` maps to `lda` (load accumulator), `add`, and `sta`.
     - `if (c == 30)` maps to `cmp` (compare) and `jz` (jump if zero).


##### Example: Mapping `c = a + b;` and `if (c == 30)`
```assembly
lda a        ; Load value of 'a'
add b        ; Add value of 'b'
sta c        ; Store the result in 'c'

lda c        ; Load value of 'c'
cmp 30       ; Compare with 30
jz label1    ; Jump to label1 if zero flag is set
hlt          ; Halt if condition is false

label1:
lda c        ; Load value of 'c'
add 1        ; Increment by 1
sta c        ; Store the result in 'c'
```

### Step 4: Create a Lexer

1. **Purpose**:
   - The lexer converts SimpleLang code into tokens, identifying keywords, operators, identifiers, and literals.

2. **Implementation**:
   - Written in C, the lexer recognizes constructs like `int`, `if`, `=`, `+`, `-`, and `{`.
   - **File**: `lexer.c`
   - **Functions**:
   - `lexAnalysis(const char *input, FILE *opFile)`: Analyzes a line of input and writes tokens to the output file.
   - `writeTk(TkType type, const char *lexeme, FILE *opFile)`: Writes a token to the output file.

3. **Execution**:
   - Compile the lexer:
     ```bash
     gcc lexer.c -o lexer
     ```
   - Run the lexer with a SimpleLang program (`example.slang`):
     ```bash
     ./lexer example.slang
     ```

4. **Example Output**:
   - Input(`example.slang`):
     ```c
     int a;
     a = 10;
     ```
   - Output(`output.l`):
     ```bash
     TOKEN_INT, int
     TOKEN_IDENTIFIER, a
     TOKEN_SEMICOLON, ;
     TOKEN_IDENTIFIER, a
     TOKEN_ASSIGN, Text: =
     Token: TOKEN_NUMBER, 10
     ```

---
### Step 5: Develop a Parser

1. **Purpose**:
   - The parser takes the tokens generated by the lexer and organizes them into a structured format called an **Abstract Syntax Tree (AST)**.

2. **Implementation**:
   - Write a parser in C/C++ to handle grammar rules for SimpleLang.
   - Validate syntax (e.g., matching braces, correct use of operators).
   - Example AST structure for `a = b + c;`:
      ```plaintext
      ASSIGN
      /   \
      a   ADD
         /   \
         b    c
      ```
   - **File**: `parser.c`
   - **Functions**:
   - `parseStmt(FILE *ipFile, FILE *outputFile, Token *token)`: Parses a statement.
   - `parseExp(FILE *ipFile, char *expression, int *isArithmetic)`: Parses an expression.
   - `parseComp(FILE *ipFile, FILE *outputFile)`: Parses a comparison.
   - `isDeclared(const char *identi)`: Checks if an identifier is declared.
   - `addIdenti(const char *identi)`: Adds a declared identifier.

3. **Execution**:
   - Input tokens from the lexer and output the corresponding AST or syntax error messages.
   - Compile parser:
     ```bash
      gcc parser.c -o parser
     ```
   - Run the parser with a Token generated File (`output.l`):
     ```bash
     ./parser output.l
     ```


4. **Example Output**:
   - Input(`output.l`):
     ```
     TOKEN_INT, int
     TOKEN_IDENTIFIER, a
     TOKEN_SEMICOLON, ;
     TOKEN_IDENTIFIER, a
     TOKEN_ASSIGN, =
     Token: TOKEN_NUMBER, 10
     ```
   - Output(`output.ast`):
     ```
     Declaration: type=int, identifier=a
     Assignment: identifier=a expression: Number(10)
     ```

---

### Step 6: Generate Assembly Code

1. **Purpose**:
   - Convert the AST into 8-bit CPU assembly instructions.

2. **Implementation**:
   - Traverse the AST and map constructs to CPU instructions:
     - Assignments (`=`): Use `lda`, `sta`.
     - Arithmetic (`+`, `-`): Use `add`, `sub`.
     - Conditionals (`if`): Use `cmp`, `jz`.
   - Example Mapping for `a = b + c;`:
     ```assembly
     lda b   ; Load b into accumulator
     add c   ; Add c to accumulator
     sta a   ; Store result in a
      ```
   - **File**: `code.c`
   - **Functions**:
   - `processAST(FILE *inFile, FILE *outFile)`: Processes the AST and generates assembly code.
   - `handleInstruction(char *line, FILE *outputFile, FILE *inFile)`: Handles individual instructions.
   - `handleArith(char *line, FILE *outputFile)`: Handles arithmetic operations.    

3. **Execution**:
   - Generate an assembly file (`output.asm`) from the AST.
   - Compile code generator:
     ```bash
      gcc code.c -o code
     ```
   - Run the code generator with a AST generated File (`output.ast`):
     ```bash
     ./code output.ast
     ```

4. **Example Output**:
   - Input(output.ast):
     ```c
     a = b + c;
     ```
   - Output(output.asm):
     ```assembly
     lda b
     add c
     sta a
     ```

---


### Step 7: Combined Compiler Implementation

1. **Purpose**:
   - You can run each component of the compiler separately but for convenience, use the `compiler.c` file to run all compilation stages at once.

2. **Implementation**: 
   - The `compiler.c` file serves as the main entry point that coordinates the execution of all three compiler phases.
   - It sequentially calls each stage and checks for errors, terminating the process if any stage fails.

   - **File**: `compiler.c`
   - **Functions**: 
     - Calls external functions `lex_main()`, `parse_main()`, and `codegen_main()` from their respective modules

3. **Execution**:
   - Compile the unified compiler:
      ```sh
      gcc compiler.c lexer.c parser.c code.c -o compiler
      ```

   - Run the compiler on your source file:
      ```sh
      ./compiler example.slang
      ```

   - This generates three files through the compilation process:
     - `output.l`: Token stream from the lexer
     - `output.ast`: Abstract Syntax Tree representation
     - `output.asm`: Final assembly code for the 8-bit computer

4. **Example Workflow**:
   - **Input File** (`example.slang`):
      ```c
      int a;
      int b;
      a = 10;
      b = a + 2;
      out(b);
      ```

   - **Running the Compiler**:
      ```sh
      $ ./compiler input.txt
      Step 1: Lexical Analysis
      Lexical success ...
      Step 2: Parsing
      Parsing tokens...
      Token parsing successful.
      Step 3: Code Generation
      Assembly code has been generated in output.asm
      Compilation process completed successfully.
      ```

   - **Generated Assembly** (`output.asm`):
      ```assembly
      .data
      a = 0
      b = 0
      tmp0 = 0
      tmp1 = 0

      .text
      start:
          ldi A 10
          sta %a

          lda %a
          mov B A
          ldi A 2
          add
          sta %b

          lda %b
          out 0

      hlt
      ```

5. **Running on the 8-bit Computer**:
   - Copy your assembly file to the 8-bit computer directory:
      ```sh
      cp output.asm /path/to/8bit-computer/output.asm
      ```

   - Generate machine code:
      ```sh
      cd /path/to/8bit-computer
      ./asm/asm.py output.asm > memory.list
      ```

   - Run the simulation:
      ```sh
      make clean && make run
      ```

   - **Example Output**:
      ```
      vvp -n computer
      VCD info: dumpfile machine.vcd opened for output.
      Memory: set [0x00] => 0x0a (10)
      Memory: set [0x01] => 0x0c (12)
      Output: 12 ($0c)
      ============================================
      CPU halted normally.
      REGISTERS: A: 0c, B: 02, C: xx, D: xx, E: xx, F: xx, G: xx, Temp: xx
      ```


## Project Features

This compiler supports a simple language with the following features:

- **Variable declarations**:
  ```
  int x;
  ```

- **Assignments**:
  ```
  x = 10;
  ```

- **Arithmetic operations** (+, -, *, /):
  ```
  x = y + 5;
  x = a * b;
  ```

- **Conditional statements(including Nested conditional statements)**:
  ```
  if (x > 5) {
    y = 10;
    if(y==10){
      out x;
    }
  } else {
    y = 20;
  }
  ```

- **Output statements**:
  ```
  out(x);
  ```

## Future Enhancements

- **Loop Constructs**: Implement `while` and `for` loops to enable iteration
- **Improved Error Messages**: Provide more specific and helpful error messages with line/column information
- **Direct Execution**: Combine the compiler with the 8-bit computer simulator for seamless compilation and execution